using CoreSpectrum.SupportClasses;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reactive.Joins;
using System.Text;
using System.Threading.Tasks;
using ZXBasicStudio.BuildSystem;
using ZXBasicStudio.Classes;
using ZXBasicStudio.Common;
using ZXBasicStudio.DocumentEditors.ZXGraphics.neg;
using ZXBasicStudio.DocumentModel.Enums;
using ZXBasicStudio.DocumentModel.Interfaces;
using static System.Runtime.InteropServices.JavaScript.JSType;
using Pattern = ZXBasicStudio.DocumentEditors.ZXGraphics.neg.Pattern;

namespace ZXBasicStudio.DocumentEditors.ZXGraphics.log
{
    /// <summary>
    /// Class to export on prebuild operation
    /// </summary>
    public class ExportManager : IZXDocumentBuilder
    {
        private FileTypes fileType = FileTypes.Undefined;

        public bool Initialize(FileTypes fileType)
        {
            this.fileType = fileType;
            return true;
        }


        public bool Build(string BuildPath, ZXBuildType BuildType, ZXProgram? program, TextWriter OutputLog)
        {
            if (!ServiceLayer.Initialized)
            {
                ServiceLayer.Initialize();
            }

            // Get all config filenames
            var files = ServiceLayer.Files_GetAllConfigFiles(BuildPath, fileType);
            if (files == null)
            {
                return true;
            }

            foreach (var file in files)
            {
                // Get export config data from config file
                var exportConfig = ServiceLayer.Export_GetConfigFile(file);
                if (exportConfig == null)
                {
                    continue;
                }

                // Build configuration sources
                var fileNameData = file.Replace(".zbs", "");
                var fileTypeConfig = ServiceLayer.GetFileType(fileNameData);
                var fileData = ServiceLayer.GetFileData(fileNameData);
                if (fileData == null || fileData.Length == 0)
                {
                    continue;
                }

                switch (fileTypeConfig.FileType)
                {
                    case FileTypes.Font:
                    case FileTypes.UDG:
                        {
                            var patterns = CreatePatterns(fileTypeConfig, fileData);
                            Export(exportConfig, fileTypeConfig, patterns);
                        }
                        break;
                    case FileTypes.Sprite:
                        {
                            var sprites = CreateSprites(fileData);
                            ExportSprites(exportConfig, sprites);
                        }
                        break;

                }

            }
            return true;
        }


        /// <summary>
        /// Export one file
        /// </summary>
        /// <param name="exportConfig">ExportConfig of the file</param>
        /// <returns></returns>
        public bool Export(ExportConfig exportConfig, FileTypeConfig fileTypeConfig, Pattern[] patterns)
        {
            // Export depending on the type
            string exportedData = "";
            switch (exportConfig.ExportType)
            {
                case ExportTypes.Bin:
                    Export_BIN(fileTypeConfig, patterns, exportConfig.ExportFilePath);
                    return true;
                case ExportTypes.Tap:
                    Export_TAP(fileTypeConfig, patterns, exportConfig);
                    break;
                case ExportTypes.Asm:
                    exportedData = Export_ASM(fileTypeConfig, patterns, exportConfig.LabelName);
                    break;
                case ExportTypes.Dim:
                    exportedData = Export_DIM(fileTypeConfig, patterns, exportConfig.LabelName, exportConfig.ArrayBase);
                    break;
                case ExportTypes.Data:
                    exportedData = Export_DATA(fileTypeConfig, patterns, exportConfig.LabelName);
                    break;
                default:
                    return true;
            }

            if (!string.IsNullOrEmpty(exportedData))
            {
                var sb = new StringBuilder();
                sb.AppendLine("'------------------------------------------------------------------------------");
                sb.AppendLine("'- Build data generated by ZXBasicStudio -------------------------------------");
                sb.AppendLine("'- Do not modify this file, its contents are deleted at each build -----------");
                sb.AppendLine("'------------------------------------------------------------------------------");
                sb.AppendLine("");
                sb.Append(exportedData);
                ServiceLayer.Files_SaveFileString(exportConfig.ExportFilePath, sb.ToString());
            }
            return true;
        }





        /// <summary>
        /// Create patterns from binary file data
        /// </summary>
        /// <param name="fileType">FileTypeConfig</param>
        /// <param name="fileData">Binary data</param>
        /// <returns>Array of Patterns or null if error</returns>
        public Pattern[] CreatePatterns(FileTypeConfig fileType, byte[] fileData)
        {
            var patterns = new List<Pattern>();

            for (int n = 0; n < fileType.NumerOfPatterns; n++)
            {
                var p = new Pattern();
                p.Id = n;
                p.Number = "";
                switch (fileType.FileType)
                {
                    case FileTypes.UDG:
                        {
                            var id = n;
                            p.Number = id.ToString();
                            var c = Convert.ToChar(n + 65);
                            p.Name = c.ToString();
                        }
                        break;
                    case FileTypes.Font:
                        {
                            var id = n + 32;
                            p.Number = id.ToString();
                            var c = Convert.ToChar(n + 32);
                            p.Name = c.ToString();
                        }
                        break;
                    default:
                        p.Number = n.ToString();
                        p.Name = "";
                        break;
                }
                p.Data = ServiceLayer.Binary2PointData(n, fileData, 0, 0);
                patterns.Add(p);
            }
            return patterns.ToArray();
        }


        /// <summary>
        /// Export to ASM format
        /// </summary>
        /// <param name="fileType">FileTyeConfig</param>
        /// <param name="patterns">Patterns with the source data</param>
        /// <param name="labelName">Name of the label</param>
        /// <returns>String with de exported data</returns>
        public static string Export_ASM(FileTypeConfig fileType, Pattern[] patterns, string labelName)
        {
            var sb = new StringBuilder();
            sb.AppendLine(labelName + ":");
            sb.AppendLine("ASM");

            var data = ServiceLayer.Files_CreateBinData_GDUorFont(fileType, patterns);
            int col = 0;

            foreach (var d in data)
            {
                if (col == 0)
                {
                    sb.Append("\tDB ");
                }
                if (col > 0)
                {
                    sb.Append(",");
                }
                var x = string.Format("${0:X2}", d);
                sb.Append(x);

                col++;
                if (col >= 8)
                {
                    sb.AppendLine("");
                    col = 0;
                }
            }

            sb.AppendLine("END ASM");

            return sb.ToString();
        }


        /// <summary>
        /// Export to DATA format
        /// </summary>
        /// <param name="fileType">FileTyeConfig</param>
        /// <param name="patterns">Patterns with the source data</param>
        /// <param name="labelName">Name of the label</param>
        /// <returns>String with de exported data</returns>
        public static string Export_DATA(FileTypeConfig fileType, Pattern[] patterns, string labelName)
        {
            var sb = new StringBuilder();
            sb.AppendLine(labelName + ":");

            var data = ServiceLayer.Files_CreateBinData_GDUorFont(fileType, patterns);
            int col = 0;
            int row = 0;
            foreach (var d in data)
            {
                if (col == 0)
                {
                    sb.Append("DATA ");
                }
                if (col > 0)
                {
                    sb.Append(",");
                }
                var x = string.Format("${0:X2}", d);
                sb.Append(x);

                col++;
                if (col >= 8)
                {
                    sb.AppendLine("");
                    col = 0;
                }
            }

            return sb.ToString();
        }


        /// <summary>
        /// Export to DIM format
        /// </summary>
        /// <param name="fileType">FileTyeConfig</param>
        /// <param name="patterns">Patterns with the source data</param>
        /// <param name="labelName">Name of the label</param>
        /// <param name="arrayBase">Array base for DIM</param>
        /// <returns>String with de exported data</returns>
        public static string Export_DIM(FileTypeConfig fileType, Pattern[] patterns, string labelName, int arrayBase)
        {
            int la = 20;
            int bt = 7;

            switch (fileType.FileType)
            {
                case FileTypes.UDG:
                    la = 20;
                    break;
                case FileTypes.Font:
                    la = 95;
                    break;
            }

            switch (arrayBase)
            {
                case 1:
                    la++;
                    bt = 8;
                    break;
                case 2:
                    {
                        var settings = ServiceLayer.GetProjectSettings();
                        if (settings != null)
                        {
                            if (settings.ArrayBase == 1)
                            {
                                la++;
                                bt = 8;
                            }
                        }

                    }
                    break;
            }

            var sb = new StringBuilder();
            sb.AppendLine(string.Format("DIM {0}({1},{2}) AS UBYTE => {{ _", labelName, la, bt));

            var data = ServiceLayer.Files_CreateBinData_GDUorFont(fileType, patterns);
            int col = 0;
            int row = 0;
            foreach (var d in data)
            {
                if (col == 0)
                {
                    if (row == 0)
                    {
                        row = 1;
                    }
                    else
                    {
                        sb.AppendLine(", _");
                    }
                    sb.Append("\t{ ");
                }
                if (col > 0)
                {
                    sb.Append(",");
                }
                var x = string.Format("${0:X2}", d);
                sb.Append(x);

                col++;
                if (col >= 8)
                {
                    sb.Append(" }");
                    col = 0;
                }
            }
            sb.AppendLine(" _");
            sb.AppendLine("}");

            return sb.ToString();
        }


        /// <summary>
        /// Export to BIN (RAW) format
        /// </summary>
        /// <param name="fileType">FileTyeConfig</param>
        /// <param name="patterns">Patterns with the source data</param>
        /// <param name="fileName">Output file name</param>
        public static void Export_BIN(FileTypeConfig fileType, Pattern[] patterns, string fileName)
        {
            var ft = fileType.Clonar<FileTypeConfig>();
            ft.FileName = fileName;
            ServiceLayer.Files_Save_GDUorFont(fileType, patterns);
        }


        /// <summary>
        /// Export to TAP format
        /// </summary>
        /// <param name="fileType">FileTyeConfig</param>
        /// <param name="patterns">Patterns with the source data</param>
        /// <param name="fileName">Output file name</param>
        public static void Export_TAP(FileTypeConfig fileType, Pattern[] patterns, ExportConfig exportConfig)
        {
            var data = ServiceLayer.Files_CreateBinData_GDUorFont(fileType, patterns);
            data = ServiceLayer.Bin2Tap(exportConfig.ZXFileName, exportConfig.ZXAddress, data);
            ServiceLayer.Files_SaveFileData(exportConfig.ExportFilePath, data);
        }


        #region Sprites


        private Sprite[] CreateSprites(byte[] fileData)
        {
            try
            {
                var dataS = Encoding.UTF8.GetString(fileData);
                var sprites = dataS.Deserializar<Sprite[]>();

                // Check attributes for ZX Spectrum mode
                foreach (var sprite in sprites)
                {
                    if (sprite != null && sprite.GraphicMode == GraphicsModes.ZXSpectrum)
                    {
                        foreach (var pattern in sprite.Patterns)
                        {
                            if (pattern.Attributes == null)
                            {
                                int cW = sprite.Width / 8;
                                int cH = sprite.Height / 8;
                                pattern.Attributes = new AttributeColor[cW * cH];
                                foreach (var attr in pattern.Attributes)
                                {
                                    attr.Ink = 1;
                                    attr.Paper = 0;
                                }
                            }
                        }
                    }
                }

                return sprites;
            }
            catch
            {
                return null;
            }
        }


        /// <summary>
        /// Export one file
        /// </summary>
        /// <param name="exportConfig">ExportConfig of the file</param>
        /// <param name="sprites">Sprites to convert</param>
        /// <returns></returns>
        public bool ExportSprites(ExportConfig exportConfig, IEnumerable<Sprite> sprites)
        {
            // Export depending on the type
            string exportedData = "";
            bool createTextFile = false;

            switch (exportConfig.ExportType)
            {
                case ExportTypes.PutChars:
                    exportedData = Export_Sprite_PutChars(exportConfig, sprites);
                    createTextFile = true;
                    break;
                default:
                    return true;
            }

            if (!string.IsNullOrEmpty(exportedData) && createTextFile)
            {
                var sb = new StringBuilder();
                sb.AppendLine("'------------------------------------------------------------------------------");
                sb.AppendLine("'- Build data generated by ZXBasicStudio --------------------------------------");
                sb.AppendLine("'- Do not modify this file, its contents are deleted at each build ------------");
                sb.AppendLine("'------------------------------------------------------------------------------");
                sb.AppendLine("");
                sb.Append(exportedData);
                ServiceLayer.Files_SaveFileString(exportConfig.ExportFilePath, sb.ToString());
            }
            return true;
        }


        /// <summary>
        /// Generate the export data for PutChars Sprites
        /// </summary>
        /// <param name="exportConfig">ExportConfig information</param>
        /// <param name="sprites">Sprites to convert</param>
        /// <returns>string with the conversion commands for the export dialog samble textbox</returns>
        public static string Export_Sprite_PutChars(ExportConfig exportConfig, IEnumerable<Sprite> sprites)
        {
            switch (exportConfig.ExportDataType)
            {
                case ExportDataTypes.DIM:
                    return Export_Sprite_PutChars_DIM(exportConfig, sprites);
                case ExportDataTypes.ASM:
                    return Export_Sprite_PutChars_ASM(exportConfig, sprites);
                case ExportDataTypes.BIN:
                    return Export_Sprite_PutChars_BIN(exportConfig, sprites);
                case ExportDataTypes.TAP:
                    return Export_Sprite_PutChars_TAP(exportConfig, sprites);
                default:
                    return "ERROR: Not implemented!";
            }
        }


        #region DIM
        public static string Export_Sprite_PutChars_DIM(ExportConfig exportConfig, IEnumerable<Sprite> sprites)
        {
            int min = 0;
            switch (exportConfig.ArrayBase)
            {
                case 1:
                    min = 1;
                    break;
                case 2:
                    {
                        var settings = ServiceLayer.GetProjectSettings();
                        if (settings != null)
                        {
                            if (settings.ArrayBase == 1)
                            {
                                min = 1;
                            }
                        }

                    }
                    break;
            }

            var sb = new StringBuilder();
            sb.AppendLine("'- Sprite definitions --------------------------------------");

            foreach (var sprite in sprites)
            {
                if (sprite == null || !sprite.Export)
                {
                    continue;
                }

                if (sprite.Frames == 0)
                {
                    continue;
                }

                if (sprite.Frames == 1)
                {
                    // Single sprite
                    // Header
                    sb.AppendLine(string.Format(
                        "DIM {0}{1}({2}) AS UByte => {{ _",
                        exportConfig.LabelName,
                        sprite.Name.Replace(" ", "_"),
                        ((sprite.Width / 8) * sprite.Height) - 1 + min));
                    // Content
                    var data = Export_Sprite_PutChars_Pattern(sprite, 0, exportConfig, 0);
                    sb.Append(data);
                    // Footer
                    sb.AppendLine("");
                }
                else if (sprite.Frames == 2 && sprite.Masked)
                {
                    // Single sprite masked
                    // Sprite
                    {
                        // Header
                        sb.AppendLine(string.Format(
                            "DIM {0}{1}({2}) AS UByte => {{ _",
                            exportConfig.LabelName,
                            sprite.Name.Replace(" ", "_"),
                            ((sprite.Width / 8) * sprite.Height) - 1 + min));
                        // Content
                        var data = Export_Sprite_PutChars_Pattern(sprite, 0, exportConfig, 0);
                        sb.Append(data);
                        // Footer
                        sb.AppendLine("");
                    }
                    // Mask
                    {
                        // Header
                        sb.AppendLine(string.Format(
                            "DIM {0}{1}_Mask({2}) AS UByte => {{ _",
                            exportConfig.LabelName,
                            sprite.Name.Replace(" ", "_"),
                            ((sprite.Width / 8) * sprite.Height) - 1 + min));
                        // Content
                        var data = Export_Sprite_PutChars_Pattern(sprite, 1, exportConfig, 1);
                        sb.Append(data);
                        // Footer
                        sb.AppendLine("");
                    }

                }
                else
                {
                    if (sprite.Masked)
                    {
                        // Sprites
                        {
                            // Header
                            sb.AppendLine(string.Format(
                                "DIM {0}{1}({2},{3}) AS UByte => {{ _",
                                exportConfig.LabelName,
                                sprite.Name.Replace(" ", "_"),
                                (sprite.Frames / 2) - 1 + min,
                                ((sprite.Width / 8) * sprite.Height) - 1 + min));
                            // Data
                            for (int n = 0; n < sprite.Patterns.Count; n += 2)
                            {
                                var data = Export_Sprite_PutChars_Pattern(sprite, n, exportConfig, 0);
                                sb.Append(data);
                            }
                            // Footer
                            sb.Append(" _\r\n}");
                            sb.AppendLine("");
                        }
                        // Masks
                        {
                            // Header
                            sb.AppendLine(string.Format(
                                "DIM {0}{1}_Mask({2},{3}) AS UByte => {{ _",
                                exportConfig.LabelName,
                                sprite.Name.Replace(" ", "_"),
                                (sprite.Frames / 2) - 1 + min,
                                ((sprite.Width / 8) * sprite.Height) - 1 + min));
                            // Data
                            for (int n = 1; n < sprite.Patterns.Count; n += 2)
                            {
                                var data = Export_Sprite_PutChars_Pattern(sprite, n, exportConfig, 1);
                                sb.Append(data);
                            }
                            // Footer
                            sb.Append(" _\r\n}");
                            sb.AppendLine("");
                        }
                    }
                    else
                    {
                        // Sprites
                        {
                            // Header
                            sb.AppendLine(string.Format(
                                "DIM {0}{1}({2},{3}) AS UByte => {{ _",
                                exportConfig.LabelName,
                                sprite.Name.Replace(" ", "_"),
                                sprite.Frames - 1 + min,
                                ((sprite.Width / 8) * sprite.Height) - 1 + min));
                            // Data
                            for (int n = 0; n < sprite.Patterns.Count; n++)
                            {
                                var data = Export_Sprite_PutChars_Pattern(sprite, n, exportConfig, 0);
                                sb.Append(data);
                            }
                            // Footer
                            sb.Append(" _\r\n}");
                            sb.AppendLine("");
                        }
                    }
                }


                // Attributes
                if (exportConfig.IncludeAttr && sprite.GraphicMode == GraphicsModes.ZXSpectrum)
                {
                    if (sprite.Frames == 1 || (sprite.Frames == 2 && sprite.Masked))
                    {
                        // Single sprite attributes
                        // Header
                        sb.AppendLine(string.Format(
                            "DIM {0}{1}_Attr({2}) AS UByte => {{ _",
                            exportConfig.LabelName,
                            sprite.Name.Replace(" ", "_"),
                            ((sprite.Width / 8) * (sprite.Height / 8)) - 1 + min));
                        // Content
                        var data = Export_Sprite_PutChars_Attribute(sprite, 0, exportConfig, 0);
                        sb.Append(data);
                        // Footer
                        sb.AppendLine("");
                    }
                    else
                    {
                        // Mulriple sprites attributes
                        // Header
                        sb.AppendLine(string.Format(
                            "DIM {0}{1}_Attr({2},{3}) AS UByte => {{ _",
                            exportConfig.LabelName,
                            sprite.Name.Replace(" ", "_"),
                            sprite.Frames - 1 + min,
                            ((sprite.Width / 8) * (sprite.Height / 8)) - 1 + min));
                        // Data
                        for (int n = 0; n < sprite.Patterns.Count; n++)
                        {
                            var data = Export_Sprite_PutChars_Attribute(sprite, n, exportConfig, 0);
                            sb.Append(data);
                        }
                        // Footer
                        sb.Append(" _\r\n}");
                        sb.AppendLine("");
                    }
                }
            }

            return sb.ToString();
        }


        private static string Export_Sprite_PutChars_Pattern(Sprite sprite, int n, ExportConfig exportConfig, int firstItem)
        {
            var sb = new StringBuilder();

            var pattern = sprite.Patterns[n];
            var data = ServiceLayer.Files_CreateBinDataUpDown(pattern, sprite.Width, sprite.Height);

            if (sprite.Frames > 1 &&
                !(sprite.Frames == 2 && sprite.Masked))
            {
                if (n > firstItem)
                {
                    sb.AppendLine(", _");
                }
                sb.AppendLine("\t{ _");
            }

            int col = 0;
            int row = 0;
            foreach (var d in data)
            {
                if (col == 0)
                {
                    if (row == 0)
                    {
                        row = 1;
                    }
                    else
                    {
                        sb.AppendLine(", _");
                    }
                    sb.Append("\t");
                    if (sprite.Frames > 1)
                    {
                        sb.Append("\t");
                    }
                }
                if (col > 0)
                {
                    sb.Append(",");
                }
                var x = string.Format("${0:X2}", d);
                sb.Append(x);

                col++;
                if (col >= 8)
                {
                    col = 0;
                }
            }
            sb.AppendLine(" _");

            if (sprite.Frames == 1)
            {
                sb.Append("}");
            }
            else
            {
                sb.Append("\t}");
            }

            return sb.ToString();
        }


        private static string Export_Sprite_PutChars_Attribute(Sprite sprite, int n, ExportConfig exportConfig, int firstItem)
        {
            var sb = new StringBuilder();

            var pattern = sprite.Patterns[n];

            if (pattern.Attributes == null)
            {
                return "";
            }

            if (sprite.Frames > 1)
            {
                if (n > firstItem)
                {
                    sb.AppendLine(", _");
                }
                sb.AppendLine("\t{ _");
            }

            int col = 0;
            int row = 0;
            foreach (var d in pattern.Attributes)
            {
                if (col == 0)
                {
                    if (row == 0)
                    {
                        row = 1;
                    }
                    else
                    {
                        sb.AppendLine(", _");
                    }
                    sb.Append("\t");
                    if (sprite.Frames > 1)
                    {
                        sb.Append("\t");
                    }
                }
                if (col > 0)
                {
                    sb.Append(",");
                }
                var x = string.Format("${0:X2}", d.Attribute);
                sb.Append(x);

                col++;
                if (col >= 8)
                {
                    col = 0;
                }
            }
            sb.AppendLine(" _");

            if (sprite.Frames == 1)
            {
                sb.Append("}");
            }
            else
            {
                sb.Append("\t}");
            }

            return sb.ToString();
        }

        #endregion


        #region ASM


        public static string Export_Sprite_PutChars_ASM(ExportConfig exportConfig, IEnumerable<Sprite> sprites)
        {
            int min = 0;

            var sb = new StringBuilder();
            sb.AppendLine("'- Sprite definitions --------------------------------------");

            // All sprites
            foreach (var sprite in sprites)
            {
                if (sprite == null || !sprite.Export)
                {
                    continue;
                }

                if (sprite.Frames == 0)
                {
                    continue;
                }

                // Header
                sb.AppendLine(string.Format(
                    "{0}{1}:",
                    exportConfig.LabelName,
                    sprite.Name.Replace(" ", "_")));
                sb.AppendLine("ASM");

                // Data frames
                for (int n = 0; n < sprite.Frames; n++)
                {
                    if (sprite.Masked && (n % 2) == 1)
                    {
                        continue;
                    }
                    // Content
                    var data = Export_Sprite_PutChars_Pattern_ASM(sprite, n, exportConfig);
                    sb.Append(data);
                }
                sb.AppendLine("END ASM");
                sb.AppendLine("");

                // Mask frames
                if (sprite.Masked)
                {
                    // Header
                    sb.AppendLine(string.Format(
                        "{0}{1}_Mask:",
                        exportConfig.LabelName,
                        sprite.Name.Replace(" ", "_")));
                    sb.AppendLine("ASM");
                    for (int n = 0; n < sprite.Frames; n++)
                    {
                        if ((n % 2) == 0)
                        {
                            continue;
                        }
                        // Content
                        var data = Export_Sprite_PutChars_Pattern_ASM(sprite, n, exportConfig);
                        sb.Append(data);
                    }
                    sb.AppendLine("END ASM");
                    sb.AppendLine("");
                }

                // Attributes
                if (exportConfig.IncludeAttr && sprite.GraphicMode == GraphicsModes.ZXSpectrum)
                {
                    // Header
                    sb.AppendLine(string.Format(
                        "{0}{1}_Attr:",
                        exportConfig.LabelName,
                        sprite.Name.Replace(" ", "_")));
                    sb.AppendLine("ASM");
                    for (int n = 0; n < sprite.Frames; n++)
                    {
                        if (sprite.Masked && (n % 2) == 1)
                        {
                            continue;
                        }
                        // Content
                        var data = Export_Sprite_PutChars_Attribute_ASM(sprite, n, exportConfig);
                        sb.Append(data);
                    }
                    sb.AppendLine("END ASM");
                    sb.AppendLine("");
                }
            }

            return sb.ToString();
        }


        private static string Export_Sprite_PutChars_Pattern_ASM(Sprite sprite, int n, ExportConfig exportConfig)
        {
            var sb = new StringBuilder();

            var pattern = sprite.Patterns[n];
            var data = ServiceLayer.Files_CreateBinDataUpDown(pattern, sprite.Width, sprite.Height);

            int col = 0;
            int row = 0;
            foreach (var d in data)
            {
                if (col == 0)
                {
                    if (row == 0)
                    {
                        row = 1;
                    }
                    else
                    {
                        sb.AppendLine("");
                    }
                    sb.Append("\tDB ");
                }
                if (col > 0)
                {
                    sb.Append(",");
                }
                var x = string.Format("${0:X2}", d);
                sb.Append(x);

                col++;
                if (col >= 8)
                {
                    col = 0;
                }
            }
            sb.AppendLine("");

            return sb.ToString();
        }


        private static string Export_Sprite_PutChars_Attribute_ASM(Sprite sprite, int n, ExportConfig exportConfig)
        {
            var sb = new StringBuilder();

            var pattern = sprite.Patterns[n];

            if (pattern.Attributes == null)
            {
                return "";
            }

            int col = 0;
            int row = 0;
            foreach (var d in pattern.Attributes)
            {
                if (col == 0)
                {
                    if (row == 0)
                    {
                        row = 1;
                    }
                    else
                    {
                        sb.AppendLine("");
                    }
                    sb.Append("\tDB ");
                }
                if (col > 0)
                {
                    sb.Append(",");
                }
                var x = string.Format("${0:X2}", d.Attribute);
                sb.Append(x);

                col++;
                if (col >= 8)
                {
                    col = 0;
                }
            }
            sb.AppendLine("");

            return sb.ToString();
        }

        #endregion


        #region TAP and BIN


        public static string Export_Sprite_PutChars_BIN(ExportConfig exportConfig, IEnumerable<Sprite> sprites)
        {
            var binData = Export_Sprite_PutChars_GetBinaryData(sprites);
            ServiceLayer.Files_SaveFileData(exportConfig.ExportFilePath, binData);
            return "";
        }


        public static string Export_Sprite_PutChars_TAP(ExportConfig exportConfig, IEnumerable<Sprite> sprites)
        {
            var binData = Export_Sprite_PutChars_GetBinaryData(sprites);
            binData = ServiceLayer.Bin2Tap(exportConfig.ZXFileName, exportConfig.ZXAddress, binData);
            ServiceLayer.Files_SaveFileData(exportConfig.ExportFilePath, binData);
            return "";
        }


        private static byte[] Export_Sprite_PutChars_GetBinaryData(IEnumerable<Sprite> sprites)
        {
            var binData=new List<byte>();

            foreach (var sprite in sprites)
            {
                if (sprite != null)
                {
                    foreach (var pattern in sprite.Patterns)
                    {
                        var data = ServiceLayer.Files_CreateBinDataUpDown(pattern, sprite.Width, sprite.Height);
                        binData.AddRange(data);
                    }
                }
            }

            return binData.ToArray();
        }

        #endregion

        #endregion
    }
}
